# ============================================================================
# Deployment — platform-api
# ============================================================================
# Production-grade Deployment with:
#   - Rolling update strategy (zero-downtime deploys)
#   - Resource requests & limits
#   - Liveness & readiness probes
#   - Security context (non-root, read-only rootfs)
#   - Anti-affinity (spread pods across nodes)
#   - Graceful shutdown (terminationGracePeriodSeconds)
#   - ConfigMap & Secret injection
# ============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: platform-api
  namespace: platform-api
  labels:
    app.kubernetes.io/name: platform-api
    app.kubernetes.io/component: api
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/managed-by: kubectl
spec:
  replicas: 3
  revisionHistoryLimit: 5
  selector:
    matchLabels:
      app.kubernetes.io/name: platform-api
      app.kubernetes.io/component: api
  strategy:
    type: RollingUpdate
    rollingUpdate:
      # Allow 1 extra pod during rollout (faster deploys)
      maxSurge: 1
      # Always keep at least N-1 pods running
      maxUnavailable: 0
  template:
    metadata:
      labels:
        app.kubernetes.io/name: platform-api
        app.kubernetes.io/component: api
        app.kubernetes.io/version: "1.0.0"
      annotations:
        # Forces pod restart when ConfigMap changes
        checksum/config: "PLACEHOLDER"
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: platform-api
      automountServiceAccountToken: false

      # ── Security Context (Pod-level) ────────────────────────────────────
      securityContext:
        runAsNonRoot: true
        runAsUser: 65532
        runAsGroup: 65532
        fsGroup: 65532
        seccompProfile:
          type: RuntimeDefault

      # ── Anti-Affinity ───────────────────────────────────────────────────
      # Spread pods across nodes for high availability.
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app.kubernetes.io/name
                      operator: In
                      values:
                        - platform-api
                topologyKey: kubernetes.io/hostname

      # ── Topology Spread ─────────────────────────────────────────────────
      # Evenly distribute across availability zones.
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: ScheduleAnyway
          labelSelector:
            matchLabels:
              app.kubernetes.io/name: platform-api

      # ── Graceful Shutdown ───────────────────────────────────────────────
      # Must be >= SHUTDOWN_TIMEOUT in the app config.
      terminationGracePeriodSeconds: 45

      containers:
        - name: platform-api
          image: platform-api:1.0.0
          imagePullPolicy: IfNotPresent

          ports:
            - name: http
              containerPort: 8080
              protocol: TCP

          # ── Environment from ConfigMap ──────────────────────────────────
          envFrom:
            - configMapRef:
                name: platform-api-config
            - secretRef:
                name: platform-api-secrets

          # ── Resource Requests & Limits ──────────────────────────────────
          # Requests: scheduler uses these for placement decisions.
          # Limits: kernel enforces these via cgroups.
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              cpu: 200m
              memory: 128Mi

          # ── Liveness Probe ──────────────────────────────────────────────
          # "Is the process alive?" If this fails, kubelet restarts container.
          livenessProbe:
            httpGet:
              path: /healthz
              port: http
            initialDelaySeconds: 5
            periodSeconds: 15
            timeoutSeconds: 3
            failureThreshold: 3
            successThreshold: 1

          # ── Readiness Probe ─────────────────────────────────────────────
          # "Can this pod serve traffic?" If this fails, pod is removed
          # from Service endpoints (no traffic routed to it).
          readinessProbe:
            httpGet:
              path: /readyz
              port: http
            initialDelaySeconds: 3
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 3
            successThreshold: 1

          # ── Startup Probe ───────────────────────────────────────────────
          # Protects slow-starting containers. Disables liveness/readiness
          # until this passes.
          startupProbe:
            httpGet:
              path: /healthz
              port: http
            initialDelaySeconds: 2
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 10

          # ── Security Context (Container-level) ──────────────────────────
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            capabilities:
              drop:
                - ALL
